
// use this instruction to switch from ensureCreat()(it is for demo and prototype applicaiton) to migrations

//**** but tacke care about the path you install your packeages ***///

// this instrucion is for another prject with different structure.

first read this : why we are switching from EnsureCreate() to Migrations:
This is the key difference between EnsureCreated() and Migrations. Letâ€™s break it down very simply:
ğŸ”¹ EnsureCreated()
It creates the database and tables immediately, based only on your 
current entity classes and DbContext.
Use case:
Good for quick demos, prototypes, testing, or throwaway apps.
When you just want: â€œI have entities â†’ please make tables now.â€
Limitations:
âŒ It cannot update the database schema if you later change your models.
âŒ If the database already exists, it wonâ€™t apply changes safely 
(you must drop & recreate).
âŒ No history of changes.
ğŸ‘‰ Think of it like:
â€œOne-shot database creation.â€

ğŸ”¹ Migrations
It creates step-by-step history of how your database schema should evolve as
your models change.
Instead of â€œjust create it,â€ you write migration files that:
Add/remove columns
Change constraints
Insert seed data
Use case:
Production or long-term projects (like OnionGolmehr).
When your schema will change over time.
Advantages:
âœ… You donâ€™t lose data when updating schema.
âœ… You can roll back/forward to different versions.
âœ… Works with team collaboration and real apps.
ğŸ‘‰ Think of it like:
â€œVersion control for your database schema.â€
ğŸ”¹ When to use which?
Learning, prototyping, testing â†’ EnsureCreated() is okay.
Real project (with updates, production, OnionGolmehr) â†’ Always use Migrations.
âœ… Thatâ€™s why I told you:
In EfCoreDemo â†’ you started with EnsureCreated() to learn faster.
But now, since youâ€™re learning real EF Core usage,
weâ€™re switching to Migrations â†’ because thatâ€™s what professionals always use in long-term projects.

// how to:

Step 0: 
First of all to use migration cli commands :
open a command windows in anywhere in your machin, (it is not has to be your project path)
run this command :
dotnet tool update --global dotnet-ef
verify the package is installed:
dotnet ef --version

Step 1: 
Remove EnsureCreated()
Find this line in your Program.cs:
using var context = new AppDbContext(options);
context.Database.EnsureCreated();
â¡ï¸ Delete it. We wonâ€™t use EnsureCreated() at all. Migrations will handle DB creation and updates.


ğŸ”¹ Step 2: Install Required Packages

(go to view/Terminal in visual studio or open a terminal windows in project .sln path)

Make sure your EfCoreDemo project has these packages:
dotnet add package Microsoft.EntityFrameworkCore
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL
dotnet add package EFCore.NamingConventions

//usage of packages
Design â†’ needed for migrations.
Npgsql â†’ PostgreSQL provider.
NamingConventions â†’ optional, for snake_case column/table names.

ğŸ”¹ Step 3: Create the First Migration
From your project folder (EfCoreDemo), run:
dotnet ef migrations add InitialCreate
This will create a Migrations/ folder inside EfCoreDemo.
EF will scan your AppDbContext and all entities in Entities/ to generate the initial SQL schema.

ğŸ”¹ Step 4: Apply Migration to Database
Run:
dotnet ef database update
This will create your PostgreSQL database and tables based on the migration.
You donâ€™t need EnsureCreated() anymore â€” migrations handle everything.

ğŸ”¹ Step 5: Verify Database
Open pgAdmin, TablePlus, or psql.
You should see:
Tables: users, posts (if we used the example entities).
Table __EFMigrationsHistory â†’ EF tracks applied migrations.
ğŸ”¹ Step 6: Future Entity Changes
Whenever you add/change entities:
Create a new migration:

very important point:
to use (dotnet ef migrations add InitialCreate) in 
design time (not run_time)  we need to specifuc AppDbContet to ef command line
using a factory methode , if we don't use this factory method we got an error 
which will say:
"say Unable to resolve service for type 'DbContextOptions<AppDbContext>"
the reason of this error is :
EF Core needs to create an instance of your DbContext (AppDbContext) 
at design-time (outside of your app running).
It doesnâ€™t know how to pass the DbContextOptions you use in
your Program.cs (because that runs only at runtime).

// this is that factory method (just put it in same path which dbcontext exist 
and it will work and recognize by Ef commands)
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
using Microsoft.Extensions.Configuration;
using System.IO;
public class AppDbContextFactory : IDesignTimeDbContextFactory<AppDbContext>
{
    public AppDbContext CreateDbContext(string[] args)
    {
        // Load configuration from appsettings.json
        var configuration = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory()) // current project folder
            .AddJsonFile("appsettings.json")              // load settings
            .Build();

        var connectionString = configuration.GetConnectionString("DefaultConnection");

        var optionsBuilder = new DbContextOptionsBuilder<AppDbContext>();
        optionsBuilder.UseNpgsql(connectionString);

        return new AppDbContext(optionsBuilder.Options);
    }
}

and then this command work like charme in cmd of project path

dotnet ef migrations add InitialCreate -p Infrastructure -s API
dotnet ef database update -p Infrastructure -s API

note (about thoes -p):

what is thoes -p you add to commands?

The -p (or --project) flag in dotnet ef commands specifies which project 
contains your DbContext and migrations.
In multi-project solutions (like your Onion Architecture with API,
Application, Infrastructure, etc.), EF Core needs to know where to put or find migrations.

Example:

Suppose your solution looks like this:

PostgresDemo.sln
â”‚
â”œâ”€â”€ API/               (Startup project, runs the app)
â”œâ”€â”€ Infrastructure/    (Contains AppDbContext)
â”œâ”€â”€ Domain/
â”œâ”€â”€ Application/

Add migration:

dotnet ef migrations add InitialCreate -p Infrastructure -s API

-p Infrastructure â†’ project where AppDbContext is defined (where migrations should be stored).
-s API â†’ startup project (the one that has Program.cs / Startup.cs and is used to run the app).

Update database:
dotnet ef database update -p Infrastructure -s API

Why we need this?
EF tools run design-time services (like creating DbContext).
In Onion / Clean Architecture, your DbContext is usually inside Infrastructure, but your startup logic (like reading appsettings.json, configuring DI, etc.) 
is in the API project.
Thatâ€™s why we point EF Core to both the DbContext project (-p) and the startup project (-s).
ğŸ‘‰ Without -p and -s, EF assumes both are in the same project (which only works in small apps, not Onion).

Apply it to DB:
dotnet ef database update

âœ… Thatâ€™s the professional workflow â€” fully compatible with what
weâ€™ll do in all projects .

// important note to delete migration : 

how can i remove migration and re create it 
. it it enough to delete folder and run commands again ?

No â€” donâ€™t just delete the Migrations folder manually. EF Core keeps track of applied migrations inside your database in a special table called __EFMigrationsHistory. If you only delete the folder, EF will get confused because 
the database still â€œremembersâ€ the old migrations.
Here are the proper ways:

âœ… Option 1: Remove the last migration (before applying it)
If you havenâ€™t run dotnet ef database update yet:
dotnet ef migrations remove -p Infrastructure -s API

ğŸ‘‰ This removes the last migration and cleans up properly.
âœ… Option 2: Reset everything (start fresh)
If you want to delete all migrations and start again:
Delete the Migrations folder in your project 
(e.g. Infrastructure/Migrations).
Drop the database:

dotnet ef database drop -p Infrastructure -s API
(It will ask for confirmation: type y.)
Create a new migration:
dotnet ef migrations add InitialCreate -p Infrastructure -s API
Apply it:
dotnet ef database update -p Infrastructure -s API
âœ… Option 3: Rebuild with new migration but keep database data
If you want to rebuild migration files but keep the existing database:
Delete the Migrations folder
Run:
dotnet ef migrations add InitialCreate -p Infrastructure -s API --ignore-changes
This will re-create migration files without re-applying changes to the DB.
âš ï¸ Summary:
If migration not applied yet â†’ dotnet ef migrations remove.
If applied and want fresh start â†’ drop DB + delete Migrations folder + re-create.
If DB should stay â†’ --ignore-changes.